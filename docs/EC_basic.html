<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>ec_basic ‚Äì Zoe PhD Info</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-2486e1f0a3ee9ee1fc393803a1361cdb.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap-52109d51d0c4eda6f299237d1ec06587.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Zoe PhD Info</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./C1-Partitioning Algorithms.html"> 
<span class="menu-text">C1-Partitioning Algorithms</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./C2-Seasonal Vars of CUE.html"> 
<span class="menu-text">C2-Seasonal Vars of CUE</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./C3-Coordination of MCUE VCUE.html"> 
<span class="menu-text">C3-Coordination of MCUE VCUE</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./EC_basic.html" aria-current="page"> 
<span class="menu-text">EC Basic</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./CUE.html"> 
<span class="menu-text">CUE Review</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://github.com/ZoeZHH" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-github"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#carbon-cycle-concepts" id="toc-carbon-cycle-concepts" class="nav-link active" data-scroll-target="#carbon-cycle-concepts">Carbon-Cycle Concepts</a></li>
  <li><a href="#u-filtering" id="toc-u-filtering" class="nav-link" data-scroll-target="#u-filtering">u* filtering</a></li>
  <li><a href="#gap-filling" id="toc-gap-filling" class="nav-link" data-scroll-target="#gap-filling">Gap-filling</a>
  <ul class="collapse">
  <li><a href="#look-up-tables-lut" id="toc-look-up-tables-lut" class="nav-link" data-scroll-target="#look-up-tables-lut">Look-up Tables (LUT)</a></li>
  <li><a href="#mean-diurnal-course-mdc" id="toc-mean-diurnal-course-mdc" class="nav-link" data-scroll-target="#mean-diurnal-course-mdc">Mean Diurnal Course (MDC)</a></li>
  <li><a href="#marginal-distribution-sampling-mds" id="toc-marginal-distribution-sampling-mds" class="nav-link" data-scroll-target="#marginal-distribution-sampling-mds">Marginal Distribution Sampling (MDS)</a></li>
  </ul></li>
  <li><a href="#daytime-partitioning-reddyprocpartitioninglasslop10.r" id="toc-daytime-partitioning-reddyprocpartitioninglasslop10.r" class="nav-link" data-scroll-target="#daytime-partitioning-reddyprocpartitioninglasslop10.r">Daytime Partitioning REddyProc/PartitioningLasslop10.R</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">




<section id="carbon-cycle-concepts" class="level2">
<h2 class="anchored" data-anchor-id="carbon-cycle-concepts">Carbon-Cycle Concepts</h2>
<p>(Chapin et al., 2006) Reconciling Carbon-cycle Concepts, Terminology, and Methods</p>
<p>Research gap and aims: NEP has been used both to represent GPP-ER and net C accumulation rate previously, leading to confusion about what NEP estimates in the literature actually represent.<br>
-&gt; this study is designed to clearly defined C-cycling concepts and terminology</p>
<p>Takeaways:</p>
<p>NEP (ecosystem-centered quantity) = GPP - ER (Ra+Rh), positive as carbon gain by ecosystem<br>
NPP = GPP - Ra<br>
NECB as net rate of C accumulation in ecosystems = dC/dt<br>
NECB = -NEE + F<sub>CO</sub> + F<sub>CH4</sub> + F<sub>VOC</sub> + F<sub>DIC</sub> + F<sub>DOC</sub> + F<sub>PC</sub><br>
NEE (atmospheric-centered quantity), positive as carbon gain by the atmosphere, negative the opposite. NEE = ER - GPP<br>
<strong>Gross primary production (GPP)</strong> is the sum of gross C fixation by autotrophic C-fixing tissues per unit ground or water area and time.<br>
<strong>Autotrophic respiration (AR)</strong> is the sum of respiration (CO2 production) by all living parts of primary producers per unit ground or water area and time.<br>
<strong>Heterotrophic respiration (HR)</strong> is the respiration rate of heterotrophic organisms (animals and microbes) summed per unit ground or water area and time.<br>
<strong>Ecosystem respiration (ER)</strong> is the respiration of all organisms summed per unit ground or water area and time.<br>
<strong>Net primary production (NPP)</strong> is GPP - AR. It includes not only the growth of primary producers (biomass accumulation and tissue turnover above and belowground in terrestrial ecosystems) but also the C transfer to herbivores and root symbionts (for example, mycorrhizal fungi), the excretion of organic C from algae, and the production of root exudates and plant VOCs (Long and others 1989; Clark and others 2001; Kesselmeier and others 2002). ‚Äú<strong>Published summaries of data on terrestrial NPP are, however, usually based on data from litterfall and aboveground biomass accumulation and therefore are not closely aligned to the concept of NPP as the imbalance between GPP and AR (Clark and others 2001)‚Äú</strong></p>
<p>A common conceptual framework (ecosystem as a volume with explicitly top, bottom and sides):</p>
<p><img src="images/Screenshot 2026-01-13 at 8.41.31 PM.png" class="img-fluid" width="331"></p>
<p>Strictly speaking, NEP ‚â† NEE<br>
NEE as Net CO‚ÇÇ flux across the ecosystem‚Äìatmosphere boundary.<br>
But NEP as Net <strong>biological imbalance</strong> between carbon fixation and respiration, may include accounts for the respiration that <em>produces</em> inorganic carbon (DIC, Organic C+O2‚Äã‚ÜíCO2+H2O, CO2‚Äã(g)‚áå CO2‚Äã(aq) and others conversions), respiration followed by lateral hydrological export, respiration in diffusion-limited environments‚Ä¶..</p>
<p>And definitely, NECB ‚â† NEP<br>
Other important fluxes include leaching loss from (or input to) the ecosystem of DOC; emission of CH4, CO, and VOCs; erosion; fire; harvest; and other vertical and lateral C transfers not include in NEP<br>
Also, when inorganic C enters or leaves ecosystems for reasons other than an imbalance between GPP and ER.</p>
<p><br>
<br>
<strong>Hints:</strong> NEE is opposite in sign to NEP and NECB because NEE is defined by atmospheric scientists as a C input to the atmosphere, whereas NEP and NECB are defined by ecologists as C inputs to ecosystems.</p>
</section>
<section id="u-filtering" class="level2">
<h2 class="anchored" data-anchor-id="u-filtering">u* filtering</h2>
<p><img src="img/u* threshold.png" alt="u* threshold" style="float: right; margin-left: 15px; " width="467" height="657"></p>
<p>At night, clear and calm conditions, atmosphere becomes stably stratified (cool air settles near ground, warm air sits above -&gt; suppress vertical mixing) -&gt; CO<sub>2</sub> produced near the surface by respiration accumulation close to the ground BUT EC measure vertical fluxes of CO<sub>2</sub> which rely on turbulence -&gt; underestimate the true respiration happening at the surface</p>
<p>Scientists assumes a threshold of u* (detect the <strong>minimum amount of turbulence</strong> needed for reliable nighttime NEE (ecosystem respiration) measurements), two methods:<br>
- The moving point method (Papale et al., 2006 https://doi.org/10.5194/bg-3-571-2006):<br>
Seperate BINS: Only nighttime data used (R<sub>g</sub> &lt; 10 W m-2) -&gt; seasonal splitting (data are split by seasons to account for changes in surface properties) -&gt; temperature subsets (each season is further split into 6 temperature bins using quantiles, to ensure homogeneity of respiration rates, temperature is closely related to respiration rates!) -&gt; within each temperature subset, u* is divided into ~20 bins with equal number of points</p>
<p>Moving Point Test: For each bin i, compute mean NEE of bin i (<span class="math inline">\(\mu_i\)</span>) and mean NEE of the next 10 bins (<span class="math inline">\(\mu_{i+1\,\ldots\,i+10}\)</span>) -&gt; Check if <span class="math inline">\(\mu_i &gt; 0.95 \times \operatorname{mean}(\mu_{i+1}, \ldots, \mu_{i+10})\)</span> and this holds for <span class="math inline">\(\mu_{i+1}\)</span>-&gt;If so, bin i‚Äôs mean u* is the threshold<br>
</p>
</section>
<section id="gap-filling" class="level2">
<h2 class="anchored" data-anchor-id="gap-filling">Gap-filling</h2>
<section id="look-up-tables-lut" class="level3">
<h3 class="anchored" data-anchor-id="look-up-tables-lut">Look-up Tables (LUT)</h3>
<p>Overview: Tables were created for each site so that missing values of F<sub>NEE</sub> could be ‚Äúlooked-up‚Äù based on environmental conditions associated with the missing data.</p>
<p><strong>Pick a gap</strong> in the cleaned (QC + u* filtered) flux data (<code>VAR_fall</code> is NA).<br>
<strong>Set the search window</strong> ‚Äî user-defined <code>WinDays.i</code> days before and after the gap; full window length = <code>2 √ó WinDays.i</code> days.<br>
<strong>Choose condition variables and tolerances</strong> ‚Äî up to 5 meteorological drivers (e.g., <code>Rg</code> ¬±50 W m‚Åª¬≤, <code>Tair</code> ¬±2.5 ¬∞C, <code>VPD</code> ¬±5 hPa).<br>
- <strong>Special rule:</strong> If the first variable is <code>Rg</code>, reduce tolerance at low light to a minimum of 20 W m‚Åª¬≤ and never exceed the original tolerance, to avoid mismatching dark and bright conditions.<br>
<strong>Find candidate records</strong> inside the time window that:<br>
- Have a measured original value (<code>VAR_orig</code> not NA), and<br>
- For each active driver, the absolute difference from the gap‚Äôs value is less than the set tolerance (using the adjusted <code>Rg</code> tolerance if applicable).<br>
<strong>Check sample size:</strong> Require at least 2 valid matches to proceed.<br>
<strong>Fill the gap:</strong><br>
- Value = mean of all matching records.<br>
- Uncertainty = standard deviation (SD) of the matching records.<br>
- <code>fnum</code> = number of matches used.<br>
<strong>Assign method code and QC:</strong><br>
- <code>fmeth = 1</code> if ‚â•3 drivers used; <code>fmeth = 2</code> if only 1 driver used.<br>
- QC = 1 for short windows (‚â§14 days full span for ‚â•3 drivers; ‚â§14 or ‚â§28 days for 1 driver), QC = 2 for medium windows, QC = 3 for long windows.<br>
<strong>Write results back:</strong> Store filled value, number of matches, SD, method code, window length, and QC in <code>VAR_fall</code> and related columns. Only fill <code>VAR_f</code> if it‚Äôs still NA.<br>
<strong>Skip if no fill:</strong> If &lt;2 matches found, leave the gap for later methods (e.g., MDC) in the MDS cascade.</p>
</section>
<section id="mean-diurnal-course-mdc" class="level3">
<h3 class="anchored" data-anchor-id="mean-diurnal-course-mdc">Mean Diurnal Course (MDC)</h3>
<p>Overview: Fills missing flux values by averaging measurements from the same time of day (¬±1 hour) on nearby days, assuming that conditions at the same time of day are similar on days close together. Medium performance but it has advantage that this approach can be used even if no meteorological information is available.</p>
<p><strong>Pick a gap</strong> in the cleaned (QC + u* filtered) flux data (<code>VAR_fall</code> is NA).<br>
<strong>Set the search window</strong> ‚Äî by default ¬±7 days around the gap (user-defined <code>WinDays.i</code>), giving a full window length of <code>2 √ó WinDays + 1</code> days.<br>
<strong>Identify same-time-of-day neighbors</strong>:<br>
Use the gap‚Äôs position in the day and collect indices for:<br>
- The current day: ¬±2 records (‚âà¬±1 hour) around the gap time.<br>
- Each day up to <code>WinDays.i</code> days before and after: same-time ¬±1 hour.<br>
<strong>Keep only measured points</strong>: Remove any candidate records where the original flux (<code>VAR_orig</code>) is NA.<br>
<strong>Check sample size</strong>: Require at least 2 valid neighbors to proceed.<br>
<strong>Fill the gap</strong>:<br>
- Value = mean of all valid neighbors.<br>
- Uncertainty = standard deviation (SD) of those neighbors.<br>
- <code>fnum</code> = number of neighbors used.<br>
<strong>Assign method code and QC</strong>:<br>
- <code>fmeth = 3</code> (MDC method).<br>
- <code>fwin</code> = number of days spanned (<code>2 √ó WinDays + 1</code>).<br>
- QC = 1 if ‚â§1 day used; 2 if &gt;1‚Äì5 days; 3 if &gt;5 days.<br>
<strong>Write results back</strong>: Store filled value, number of points, SD, method code, window length, and QC in <code>VAR_fall</code> and related columns. Only fill <code>VAR_f</code> if it‚Äôs still NA.</p>
</section>
<section id="marginal-distribution-sampling-mds" class="level3">
<h3 class="anchored" data-anchor-id="marginal-distribution-sampling-mds">Marginal Distribution Sampling (MDS)</h3>
<div class="quarto-figure quarto-figure-center" style="float: right; margin-left: 15px;">
<figure class="figure">
<p><img src="img/gapfilling.png" width="450" height="350" class="figure-img"></p>
<figcaption>gap filling</figcaption>
</figure>
</div>
<p>Overview: To solve the 1) covariation of the fluxes with the meteorological variables and 2) temporal autocorrelation based on LUT and MDC</p>
<p>(1) Only the data of direct interest are missing, but all meteorological data are available<br>
-&gt; [LUT] the missing value is replaced by the average value under similar meteorological conditions within a time-window of 7 days. Similar meteorological conditions are present when Rg, Tair and VPD do not deviate by more than 50 W m 2, 2.5 1C, and 5.0 hPa, respectively. If no similar meteorological conditions, averaging window is increased to 14 days.<br>
(2) Air temperature or VPD is missing, but radiation is available<br>
-&gt; the same approach is taken, but similar meteorological conditions can only be defined via Rg deviation less than 50 W m 2<br>
(3) Radiation data is missing<br>
-&gt; the missing value is replaced by the average value at the same time of the day (1 h), i.e.&nbsp;by the mean diurnal course. In this case, the window size starts with 0.5 days</p>
<p>For other gap filling methods and related evaluations, 10.1016/j.agrformet.2007.08.011</p>
</section>
</section>
<section id="daytime-partitioning-reddyprocpartitioninglasslop10.r" class="level2">
<h2 class="anchored" data-anchor-id="daytime-partitioning-reddyprocpartitioninglasslop10.r">Daytime Partitioning REddyProc/PartitioningLasslop10.R</h2>
<ol type="1">
<li><p>Entry Points: partitionNEEL () &amp; partGLControl () partitionNEEL () is the master (wrapper) function that orchestrates all the sub-functions ‚Äî it calls every key step of daytime partitioning in sequence: extract data ‚Üí fit nighttime temperature sensitivity ‚Üí fit daytime light-response curves ‚Üí interpolate parameters ‚Üí predict Reco and GPP ‚Üí output results.<br>
partGLControl () is the ‚Äúknobs panel‚Äù for daytime partitioning.<br>
<strong>isFilterMeteoQualityFlag (default False)</strong>; If TRUE, the LRC fit uses only non-gapfilled met drivers (Temp, VPD, Rg) where the _QC == 0. Predictions still use gapfilled drivers.<br>
<strong>isLasslopPriorsApplied (default TRUE);</strong> Applies strong fixed priors/constraints on LRC parameters (Œ±, Œ≤, k, Rref) in sparse/ill-conditioned windows.<br>
<strong>smoothTempSensEstimateAcrossTime (default TRUE)</strong>, Smooths the nighttime E0(t) estimates across windows before using them in daytime fits.<br>
<strong>isBoundLowerNEEUncertainty (default TRUE);</strong> Prevents tiny NEE_SE from giving a few points huge leverage (bounds sdNEE to max(0.2¬∑|NEE|, 0.7)).<br>
<strong>replaceMissingSdNEEParms (default c(0.2, 0.7))</strong> and <strong>neglectNEEUncertaintyOnMissing (default FALSE);</strong> If NEE_SE is missing, replace with 20% of |NEE| but at least 0.7; OR if you set neglectNEEUncertaintyOnMissing=TRUE, set all sdNEE=1 when any are missing in a window.<br>
<strong>minNRecInDayWindow (default 10)</strong>; Minimum valid daytime records per window for fitting. If too high, you get NA windows (lost parameters ‚Üí more interpolation). Too low ‚Üí unstable fits.<br>
<strong>isNeglectVPDEffect (default FALSE)</strong> and <strong>isRefitMissingVPDWithNeglectVPDEffect (default TRUE).</strong> If VPD is scarce/missing, auto-refit LRC without VPD and use those parameters for predictions with missing VPD.<br>
<strong>fixedTempSens (E0, sdE0, RRef)</strong> If you provide a fixed E0 (and optionally RRef), REddyProc skips nighttime E0 estimation and uses your E0 (with sdE0 for bootstrap).<br>
<strong>useNightimeBasalRespiration (default FALSE)</strong> Implements Keenan (2019) modification: recompute nighttime Reco from nighttime-based Rref rather than daytime basal respiration.<br>
<strong>isNeglectPotRadForNight (default FALSE)</strong> Defines night using only Rg‚â§4 (ignoring potential radiation).<br>
<strong>LRCFitConvergenceTolerance / nLRCFitConvergenceTolerance</strong> Optimizer tolerances. Tighter ‚Üí more precise but slower; looser ‚Üí faster but slightly different parameters.<br>
<strong>isUsingLasslopQualityConstraints (default FALSE)</strong> and <strong>minPropSaturation (default NA):</strong> Extra data quality checks (beyond original Lasslop constraints) and a ‚Äúsufficient saturation‚Äù criterion.<strong><br>
nBootUncertainty (default 30)</strong> and <strong>isSdPredComputed (default TRUE)</strong> Bootstrap parameter SDs and propagate to sdReco/sdGPP. 30 is a good balance; set 0 for speed when you don‚Äôt need SDs.<br>
</p></li>
<li><p>Inputs and screening: partGLExtractStandardData() and replaceMissingSdByPercentage()</p>
<p>1) partGLExtractStandardData() as the ‚Äúclean-room loader‚Äù for daytime partitioning. It pulls the right columns from your input <code>ds</code>, applies quality flags the way you ask it to, decides which timesteps are day vs night (Lasslop-style), and prepares a compact data.frame that all later steps use.<br>
<strong>Inputs &amp; Controls:</strong><br>
NEEVar (NEE_f), QFNEEVar (NEE_fqc), QFNEEValue (default 0, which treated as ‚Äúgood/original‚Äù), NEESdVar (NEE_fsd)<br>
TempVar (Tair_f), QFTempVar (Tair_fqc), QFTempValue (as 0),<br>
VPDVar(VPD_f), QFVPDVar (VPD_fqc), QFVPDValue (as 0),<br>
RadVar (Rg_f), QFRadVar (Rg_fqc), QFRadValue (as 0),<br>
PotRadVar (PotRad_NEW)<br>
controlGLPart$isFilterMeteoQualityFlag (default as False), use the filled met drivers as-is<br>
If TRUE, replace met drivers with only the ‚Äúgood/original‚Äù records per their QC flags; otherwise set to NA<br>
controlGLPart$isNeglectPotRadForNight (default as False), day/night uses both Rg threshold and PotRad sign, TRUE by day/night depends only on Rg threshold<br>
<strong>Quality-flag filtering:<br>
</strong>fSetQF(ds, NEEVar, QFNEEVar, QFNEEValue), returns NEEFiltered: keeps only rows where the QF equals QFNEEValue (usually 0). Others become NA. This ensures daytime LRC fits don‚Äôt ‚Äútrust‚Äù gap-filled NEE (consistent with Lasslop).<br>
Meteo drivers (only if isFilterMeteoQualityFlag == TRUE): NEW_FP_Temp = fSetQF(Tair_f, Tair_fqc, 0) else ds[[‚ÄúTair_f‚Äù]]; NEW_FP_VPD = fSetQF(VPD_f, VPD_fqc, 0) else ds[[‚ÄúVPD_f‚Äù]]; NEW_FP_Rg = fSetQF(Rg_f, Rg_fqc, 0) else ds[[‚ÄúRg_f‚Äù]]<br>
Most people leave isFilterMeteoQualityFlag = FALSE so that filled met drivers drive the prediction stage but are not required to be ‚Äúoriginal‚Äù for fitting (Lasslop‚Äôs standard practice still requires original/good NEE for fitting).<br>
<strong>Day/Night Flags:<br>
</strong>Radiation threshold: Rg &gt; 4 ‚Üí day; Rg ‚â§ 4 ‚Üí night (Lasslop 2010)<br>
Potential radiation guard (to avoid twilight artifacts): If isNeglectPotRadForNight == FALSE (default): isNight = (Rg ‚â§ 4) &amp; (PotRad ‚â§ 0); isDay = (Rg &gt; 4) &amp; (PotRad &gt; 0) If TRUE, the PotRad conditions are dropped: isNight = (Rg ‚â§ 4); isDay = (Rg &gt; 4)<br>
<strong>Outputs:<br>
</strong>partGLExtractStandardData() returns a compact data.frame named (by you) dsR with:<br>
sDateTime: just ds[[1]] (the first column, usually timestamps; kept for debugging) NEE: quality-filtered NEE (others are NA) sdNEE: standard deviation (uncertainty) of NEE; may be modified next step Temp: temperature series (possibly QC-filtered if you opted in) VPD: VPD series (possibly QC-filtered if you opted in) Rg: radiation series (possibly QC-filtered if you opted in) isDay: logical isNight: logical<br>
<br>
</p>
<ol start="2" type="1">
<li>replaceMissingSdByPercentage() This is a tiny, vectorized helper that fills only the missing entries of a standard deviation vector using a conservative rule tied to the signal magnitude.<br>
SIGNATURE: replaceMissingSdByPercentage &lt;- function(sdX, x, perc = 0.2, minSdX = 0.7)<br>
For every record where the uncertainty (sdNEE) is missing, we fill it with the larger of two values: 20% of the absolute NEE flux magnitude, or 0.7 (the minimum allowed uncertainty).This way, all data points have a reasonable uncertainty estimate for weighting during light-response-curve fitting.</li>
</ol></li>
<li><p>Nighttime temperature sensitivity:R/PartitioningLasslop10Nighttime.R<br>
partGLFitNightTimeTRespSens(), estimate the night-based respiration parameters required by the daytime (Lasslop-style) partitioning: E0, sdE0 and Rref.<br>
<strong>Inputs and Windowing:<br>
</strong>Inputs: data with columns NEE, Temp (¬∞C), isNight, isDay, (and typically sdNEE, Rg, VPD present).<br>
Windowing: winSizeNight (default 12 days): length of each night fit window.<br>
winSizeRefInDays (default 4 days): reference/anchor window (aligns centers for daytime partitioning, which uses 4 days windows).<br>
strideInDays (default 2 days): step between window centers (creates overlap).<br>
nRecInDay (default 48): records per day (half-hourly data).<br>
For robustness, winExtendSizes (default 24 &amp; 48 days), larger windows tried if 12-day fit fails (only if controlGLPart$isExtendTRefWindow = TRUE).<br>
<strong>Processing STEPS:<br>
</strong>1) Estimate E0 per window. For each window, calls partGLFitNightTempSensOneWindow(), which 1) Filters to valid night records (finite NEE &amp; Temp, isNight=TRUE; optionally trims ‚â§ ‚àí1 ¬∞C if enough points); 2) Chooses fit reference temperature TRefFit (median night Temp unless fixed in control); 3) Fits Lloyd‚ÄìTaylor on (NEE vs Temp) to get E0, sdE0, and RRefFit (at TRefFit). If ùê∏0‚àâ[50, 400] or fit fail E0 = NA<br>
</p>
<ol start="2" type="1">
<li>Recover failed E0 windows by extending window size (optional). If some E0 are NA and controlGLPart$isExtendTRefWindow=TRUE, repeat Step 2 for larger windows (winExtendSizes, e.g., 24d then 48d) and fill only those windows that were NA.<br>
</li>
<li>Sanity check for too few valid E0. If fewer than 5 finite E0 and fewer than 10% of windows succeed ‚Üí stop(); the series is too sparse to proceed.<br>
</li>
<li>Preserve raw estimates before smoothing. Copy E0 ‚Üí E0Fit, sdE0 ‚Üí sdE0Fit (bookkeeping).<br>
</li>
<li>Smooth E0 over time (optional), happened through Year-by-year Gaussian Process smoothing (via mlegp), using sdE0^2 as nugget when controlGLPart$smoothTempSensEstimateAcrossTime = TRUE<br>
</li>
<li>Estimate RRef at 15 ¬∞C using smoothed E0. alls applyWindows() with partGLFitNightRespRefOneWindow(), With E0 fixed for that window and compute Rref.<br>
</li>
<li>Fill leading NA in RRef.<br>
</li>
<li>Return the parameter series.</li>
</ol></li>
<li><p>Daytime fitting over moving windows partGLFitLRCWindows(), partGLFitLRCOneWindow()<br>
partGLFitLRCOneWindow() fits the rectangular hyperbolic LRC in a single daytime window, using E0 (sdE0) and RRef that were determined from nighttime for that same window.<br>
<br>
partGLFitLRCWindows() loops over many windows, calls partGLFitLRCOneWindow() repeatedly, collects all results, merges them with the corresponding nighttime E‚ÇÄ and RRef, and returns one tidy data frame of window-wise parameters.</p></li>
<li><p>The light-response model families RectangularLRCFitter(), NonrectangularLRCFitter() / LogisticSigmoidLRCFitter()</p></li>
<li><p>Bootstrap &amp; Uncertainty .bootStrapLRCFit(), Prediction SDs in partGLInterpolateFluxes()</p></li>
<li><p>From windows to HH, partGLInterpolateFluxes(), .partGPAssociateSpecialRows()</p></li>
<li><p>Nighttime Reco override &amp; covariances .computeRecoNight(),computeAggregatedCovariance() (helper)</p></li>
</ol>
<p>GPP records:<br>
(Rowland et al., 2014) /Aggregated Canopy Model/ Eastern Amazonian Forest/3756.7 +-19.1 gC m-2 yr-1<br>
(Zanotelli et al., 2013)/EC/An apple chard/1263 ¬± 189 gC m-2 yr-1 [Following Reichstein et al.&nbsp;(2005), GPP was 1074, Reco 723 and NEP 351 g C m‚àí2 yr‚àí1. Following Lasslop et al.&nbsp;(2010), these values were 945, 433 and 512 g C m‚àí2 yr‚àí1, respectively.]</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "Óßã";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>¬© Copyright 2023, Hehan (Zoe) Zhang</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with <a href="https://quarto.org/">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>